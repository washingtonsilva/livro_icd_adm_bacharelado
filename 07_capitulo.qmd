# Introdução à Linguagem R {#sec-R}

O objetivo deste capítulo é apresentar os fundamentos da linguagem R 
necessários para que você consiga criar objetos, trabalhar com os tipos 
de dados mais comuns e manipular as principais estruturas de dados. Esses 
fundamentos constituem a base para todos os capítulos seguintes do livro. 
O conteúdo foi elaborado para estudantes de Administração sem experiência 
prévia em programação.



## O que é R?

R é um ambiente para computação estatística e visualização de dados. Esse 
sistema é composto por duas partes: a própria **linguagem** R (que é o 
que a maioria das pessoas querem dizer quando falam sobre R) e um 
**ambiente de tempo de execução** (*runtime environment*).

R é uma linguagem **interpretada**, o que significa que os usuários acessam 
suas funções por meio de um interpretador de linha de comando. E, ao 
contrário de linguagens como Python e Java, R não é uma linguagem 
de programação de uso geral. 

A linguagem R é uma linguagem de domínio específico (*Domain Specific 
Language*, DSL). No caso de R, o domínio é a computação estatística. Por extensão, 
R é comumente usada para todos os tipos de tarefas de ciência de dados.

A linguagem R está equipada com um grande conjunto de funções internas 
para a manipulação, análise e visualização de dados. Além das funções internas 
da linguagem, existem milhares de pacotes ou bibliotecas (como os
módulos de Python) que estendem as capacidades da linguagem.



## Por que usar a linguagem R?

**Gratuita e de código aberto**: Diferentemente de softwares estatísticos 
proprietários, R é completamente gratuito e seu código-fonte é aberto, 
permitindo total transparência e personalização.

**Especialmente projetada para análise estatística e ciência de dados**: 
Enquanto outras linguagens podem ser adaptadas para estas tarefas, R foi 
concebida especificamente para computação estatística e visualização 
de dados.

**Ampla comunidade acadêmica e profissional**: R possui uma comunidade 
ativa de usuários que contribuem constantemente com novos pacotes, métodos e 
soluções para problemas complexos.

**Integração com o sistema Quarto**: Perfeita compatibilidade com o 
sistema de publicação Quarto, permitindo a criação de documentos, 
apresentações e websites dinâmicos e reproduzíveis.

**Ecossistema Tidyverse**: O conjunto de pacotes Tidyverse fornece 
uma gramática consistente para manipulação, visualização e modelagem 
de dados, especialmente útil para iniciantes.

**Excelência em visualização de dados**: Pacotes como ggplot2 permitem 
criar visualizações estatísticas sofisticadas e personalizáveis.

**Relevância no mercado**: Profissionais com conhecimento em R são 
valorizados em setores como finanças, consultorias, pesquisa de mercado 
e análise de negócios.

**Reprodutibilidade científica**: R facilita a implementação de 
práticas de ciência reproduzível, essencial para pesquisas acadêmicas 
e relatórios corporativos auditáveis.

**Versatilidade em tipos de análise**: Desde estatísticas descritivas 
simples até modelos complexos de machine learning e econometria aplicada, 
R oferece ferramentas para diversos níveis de análise.

**Documentação extensa**: Ampla disponibilidade de documentação, 
tutoriais, livros e recursos online, facilitando o aprendizado contínuo.



::: {.callout-tip}
## Vídeo sobre a linguagem R

Para finalizar esta introdução, assista o vídeo a seguir sobre a 
linguagem R disponibilizado pelo 
[R Consortium](https://r-consortium.org){target="_blank"}: 

{{< video https://www.youtube.com/watch?v=XcBLEVknqvY
    title="What is R?"
    aspect-ratio="21x9" 
>}}

:::



## Origens da Linguagem R

**A linguagem S**

A linguagem S foi desenvolvida em meados da década de 1970 por John Chambers 
no lendário Bell Labs. O objetivo era oferecer uma abordagem interativa 
para a computação estatística, que fosse fácil de usar e tornasse as tarefas 
de análise de dados mais fáceis e rápidas.

Em uma entrevista de 2013, Chambers observou que a equipe do Bell Labs 
queria que as pessoas começassem em um ambiente interativo, onde não 
pensassem em si como programadores. Então, à medida que 
suas necessidades se tornaram mais claras e sua sofisticação aumentasse, 
eles deveriam ser capazes de se orientar gradualmente para a programação 
com a linguagem S.

A filosofia geral de S era muito semelhante à de R: oferecer um ambiente 
de software que facilitasse a programação computacional e a análise 
estatística, que qualquer um possa aprender a usar.

Como R, S também pode ser usada para escrever programas mais longos 
centrados em tarefas estatísticas. Ao contrário de R, no entanto, S e 
sua iteração posterior, *S-Plus*, eram produtos licenciados, o que 
significa que tinham que ser comprados de uma empresa.

Portanto, é importante notar que a linguagem R é um dialeto da 
linguagem S.


**Sintaxe e Semântica**

Os linguistas usam os termos sintaxe e semântica para descrever elementos 
de linguagens naturais, e os cientistas da computação também adotaram 
esses termos para linguagens de programação.

Na programação de computadores, a sintaxe se refere às regras que ditam 
a 'ortografia' e a 'gramática' de uma linguagem, enquanto a semântica 
se refere a como os dados ou comandos de uma linguagem são apresentados.

A sintaxe de R era muito semelhante à de S em seus primeiros anos. Isso 
tornou mais fácil para as pessoas que usavam *S-Plus* mudar para R, o que 
desempenhou um papel fundamental na eventual popularidade de R na academia. 

A semântica de R, no entanto, está mais próxima da linguagem Scheme, 
uma linguagem de programação funcional.


**R é uma linguagem de baixo ou alto nível?**

R é considerada uma linguagem de programação de alto nível. Essa 
classificação é baseada em seu nível de abstração da linguagem 
de máquina. 

Ao contrário das linguagens de baixo nível que exigem conhecimento 
aprofundado da memória e dos processos do computador, linguagens de 
alto nível como R são projetadas para serem facilmente compreendidas 
e escritas por humanos, tornando-as mais acessíveis para estatísticos, 
analistas de dados e pesquisadores.


::: {.callout-note icon="false"}
## Um Breve Histórico da Linguagem R

- **1991**: Os professores e estatísticos Ross Ihaka e Robert Gentleman 
começam a trabalhar em um novo dialeto da linguagem S como um projeto de 
pesquisa para o Departamento de Estatística da Universidade de Auckland 
na Nova Zelândia.

- **1993**: O primeiro anúncio de R chega ao público através do arquivo de 
dados StatLib e da lista de discussão s-news.

- **1995**: O estatístico Martin Mächler convence os criadores de R a lançar 
a linguagem sob uma licença pública geral GNU, tornando R gratuita e 
de código aberto. Ihaka e Gentleman lançam seu artigo seminal apresentando 
R ao mundo.

- **1997**: O R Core Team foi formado, este grupo é o único com acesso ao 
código-fonte R. No mesmo ano, foi criada a 
*Comprehensive R Archive Network* (CRAN). Este repositório de pacotes R 
ajuda os profissionais em inúmeras tarefas.

- **2000**: R versão 1.0.0 foi lançada ao público.

- A versão atual do R pode ser consultada em 
[https://cloud.r-project.org](https://cloud.r-project.org){target="_blank"}.
:::



## Instalando a Linguagem R

1.  Acesse [https://cloud.r-project.org/](https://cloud.r-project.org/){target="_blank"}

2.  Selecione o sistema operacional, clicando em **Download R for Windows** 
por exemplo.

3.  Na página seguinte clique em **base**.

4.  Clique no link de download da versão mais recente do R para o seu 
sistema operacional. 

5.  Feito o download basta ir clicando em próximo/next até a instalação 
ser concluída.



## RStudio: Ambiente de Desenvolvimento para R

Para uma experiência de programação mais produtiva com R, recomenda-se 
fortemente o uso do RStudio, um IDE (Ambiente de Desenvolvimento Integrado) 
especialmente projetado para trabalhar com a linguagem R. Consulte o
@sec-rstudio para instalar e configurar o RStudio, entre outras 
instruções.

Embora seja perfeitamente possível utilizar a linguagem R com outros 
ambientes de desenvolvimento, como Visual Studio Code e outros, a 
combinação (R + RStudio) facilita a aprendizagem, devido à simplicidade 
e eficiência do RStudio.

Nas próximas seções deste capítulo vamos explorar os conceitos básicos 
da linguagem R, que servirão como alicerce para os tópicos posteriores. 




## Objetos e Variáveis em R

Em R, os termos "variável" e "objeto" são frequentemente usados de 
forma intercambiável, o que pode causar confusão inicial, especialmente 
para quem já possui experiência com outras linguagens de programação. 
Esta seção esclarece essa terminologia para facilitar seu aprendizado.


### A Filosofia "Tudo é um Objeto" em R

R segue uma filosofia fundamental: **tudo que existe em R é um objeto**. 
Isso significa que todos os elementos que você manipula — desde 
números simples até funções complexas — são tratados como objetos. 

Esta abordagem difere de muitas outras linguagens de programação que 
fazem distinção clara entre "variáveis primitivas" (como números) e 
"objetos" (estruturas mais complexas).

Quando criamos algo em R usando um operador de atribuição (`<-`), 
estamos essencialmente:

1. Criando um objeto na memória do computador
2. Atribuindo um nome a esse objeto para referenciá-lo posteriormente

Por exemplo, em `idade <- 25`, criamos um objeto do tipo numérico 
com valor 25 e o nomeamos como "idade". Este nome funciona como uma 
etiqueta que nos permite acessar e manipular o objeto.



### Por que usarei "variável" e "objeto" de forma intercambiável?

Por questões de clareza e para facilitar seu aprendizado, utilizarei 
o termo **variável** principalmente quando falarmos de 
valores simples que "variam", como números, textos ou valores lógicos. 
Este termo é mais intuitivo para iniciantes e comum em estatística 
e análise de dados.

Utilizarei o termo **objeto** quando precisarmos enfatizar a 
natureza mais complexa de algumas estruturas em R, como data frames, 
listas, funções ou quando discutirmos conceitos mais avançados.

Em muitos contextos, usarei ambos os termos de forma intercambiável, 
refletindo a prática comum na comunidade R.

Esta flexibilidade terminológica espelha a documentação oficial da 
linguagem R e a literatura sobre a linguagem, preparando você 
para diferentes materiais que poderá encontrar em sua jornada 
de aprendizado.




::: {.callout-tip}
## Uma Analogia Útil

Imagine uma biblioteca onde cada livro é um "objeto" de dados:

- O **conteúdo do livro** representa os dados ou valores armazenados.

- O **título na lateral** representa o nome da variável

- As **prateleiras e estantes** representam a memória do computador

- O **catálogo da biblioteca** equivale ao ambiente R, que mantém 
registro de onde cada objeto está armazenado

Quando você cria uma variável como `receita <- 5000`, é como se estivesse 
colocando um novo livro (com o conteúdo "5000") na biblioteca e 
rotulando sua lateral como "receita" para poder encontrá-lo depois.
:::


Este entendimento sobre variáveis e objetos em R estabelece uma base 
conceitual importante antes de mergulharmos nos tipos específicos de 
dados e em como manipulá-los para análises eficazes.





## Variáveis e Atribuição de Valores

Em R, a **atribuição de valores a variáveis** é fundamental para armazenar e 
manipular dados. Por exemplo, podemos criar variáveis para armazenar 
informações financeiras, como receitas, custos e lucros:

```{r}
# Exemplo: Atribuição de valores a variáveis
receita_mensal <- 850000  # Receita mensal da empresa
custos_mensais <- 500000  # Custos mensais

# Cálculo do lucro
lucro_mensal <- receita_mensal - custos_mensais  
lucro_mensal
```

Todas as instruções R com as quais criamos variáveis ou objetos têm 
o mesmo formato:

```{r}
#| eval: false
#| echo: true

nome_do_objeto <- valor
```

Lemos esse código como: "*valor é atribuído a nome_objeto*"

Em R, podemos atribuir informações às variáveis (ou objetos) utilizando 
os seguintes operadores de atribuição:

```{r}
#| label: op-atribuicao
#| echo: true

# Operador de atribuicão recomendado (<-) 
receita_mensal <- 850000
receita_mensal

# Alternativa (=), funciona
lucro_operacional = 320000
lucro_operacional
```

Em R, como em todas as linguagens, fazemos muitas atribuições de 
valores a variáveis, e não é agradável digitar o operador manualmente. 

Assim, o RStudio oferece um atalho de teclado simples para inserir 
o operador `<-`:

- Atalho do RStudio: `Alt + -` (Windows/Linux) ou `Option + -` (Mac)

- Observe que o RStudio automaticamente envolve `<-` 
com **espaços**, o que é uma boa prática de formatação de código.

- Códigos sem espaços são difíceis de ler compare: 

`lucro<-receita-custos` versus 

`lucro <- receita - custos`



## O que é uma Função em R?

Ao longo deste capítulo, usaremos diversas funções da linguagem R 
como `print()`, `typeof()`, `class()`, `c()` e `mean()`. Antes de prosseguir, 
é importante entender o que é uma função e como ela funciona.

Uma **função** em R é um bloco de código pré-definido que realiza uma 
tarefa específica. Se os objetos são os "substantivos" da linguagem R, 
as funções são os **"verbos"** — elas executam ações sobre os dados. 
Toda função segue a mesma estrutura:

```{r}
#| eval: false
#| echo: true

nome_da_funcao(argumento1, argumento2, ...)
```

Os **argumentos** são as informações que você fornece à função para 
que ela realize seu trabalho. Alguns argumentos são obrigatórios; 
outros são opcionais e possuem valores padrão.

```{r}
# sqrt() calcula a raiz quadrada - recebe um argumento
sqrt(225)

# round() arredonda um número
# o argumento 'digits' define o número de casas decimais
round(3.14159, digits = 2)

# nchar() conta o número de caracteres em um texto
nchar("Administração")
```

Observe o padrão: o nome da função vem sempre seguido de **parênteses**, 
e os argumentos ficam dentro dos parênteses, separados por vírgulas. 
Se você digitar apenas o nome da função sem os parênteses (por exemplo, 
`mean` em vez de `mean()`), R exibirá o código-fonte da função em vez 
de executá-la.


### Como Acessar a Documentação de uma Função

R possui documentação integrada para todas as suas funções. Para 
consultar a ajuda de qualquer função, use `?` ou `help()`:

```{r}
#| eval: false
#| echo: true

# Duas formas equivalentes de acessar a documentação
?mean
help(mean)
```

A documentação exibe a descrição da função, seus argumentos, valores 
de retorno e exemplos de uso. Consultar a documentação é uma prática 
essencial para aprender novas funções de forma autônoma.



## Operadores em R

Operadores são símbolos que indicam ao R qual operação realizar sobre 
valores ou objetos. Existem três grupos principais que serão utilizados 
ao longo deste livro.


### Operadores Aritméticos

Utilizados para realizar cálculos matemáticos:

| Operador | Operação         | Exemplo              | Resultado |
|----------|------------------|----------------------|-----------|
| `+`      | Adição           | `500 + 300`          | `800`     |
| `-`      | Subtração        | `850000 - 500000`    | `350000`  |
| `*`      | Multiplicação    | `150 * 30`           | `4500`    |
| `/`      | Divisão          | `350000 / 850000`    | `0.4118`  |
| `^`      | Potenciação      | `2^10`               | `1024`    |
| `%%`     | Resto da divisão | `10 %% 3`            | `1`       |
| `%/%`    | Divisão inteira  | `10 %/% 3`           | `3`       |

```{r}
# Cálculo da margem operacional
receita  <- 500000
custos   <- 320000
margem   <- (receita - custos) / receita
margem
```



### Operadores de Comparação

Comparam dois valores e retornam `TRUE` ou `FALSE`:

| Operador | Significado       | Exemplo             |
|----------|-------------------|---------------------|
| `==`     | Igual a           | `meta == 100000`    |
| `!=`     | Diferente de      | `status != "ativo"` |
| `>`      | Maior que         | `lucro > 0`         |
| `<`      | Menor que         | `estoque < 10`      |
| `>=`     | Maior ou igual    | `nota >= 7`         |
| `<=`     | Menor ou igual    | `desconto <= 0.20`  |

```{r}
lucro <- 180000
lucro > 0          # A empresa está lucrativa?
lucro >= 200000    # A meta de R$ 200 mil foi atingida?
```


### Operadores Lógicos

Combinam condições e retornam `TRUE` ou `FALSE`:

| Operador | Significado | Exemplo                              |
|----------|-------------|--------------------------------------|
| `&`      | E (AND)     | `lucro > 0 & inadimplencia < 0.05`   |
| `\|`     | OU (OR)     | `regiao == "SP" \| regiao == "RJ"`   |
| `!`      | NÃO (NOT)   | `!meta_atingida`                     |

```{r}
lucro         <- 180000
inadimplencia <- 0.03

# Empresa saudável: lucrativa E inadimplência baixa
lucro > 0 & inadimplencia < 0.05
```


::: {.callout-note}
## Operadores `&` e `|` vs. `&&` e `||`

Em R existem dois conjuntos de operadores lógicos: `&` e `|` operam 
**elemento a elemento** em vetores (mais usados em análise de dados), 
enquanto `&&` e `||` avaliam apenas o **primeiro elemento** (usados 
em estruturas de controle como `if`). Para filtrar dados, use sempre 
`&` e `|`.
:::



## Comentários em R

Nos exemplos anteriores, você já viu o símbolo `#` sendo usado. Em R, 
tudo que aparece após o `#` em uma linha é um **comentário** — o R 
ignora esse texto ao executar o código.

Comentários servem para documentar o que o código faz, facilitando 
a compreensão por outras pessoas (ou por você mesmo no futuro):

```{r}
#| eval: false
#| echo: true

# Calcula a receita líquida após impostos
receita_liquida <- receita_bruta * (1 - aliquota_imposto)

margem <- receita_liquida / receita_bruta  # margem líquida
```

Boas práticas para comentários:

- Comente o **porquê**, não o óbvio. Não escreva `# soma a e b` antes de 
  `a + b`.
- Use comentários para explicar decisões de análise ou regras de negócio.
- Mantenha os comentários atualizados quando alterar o código.

::: {.callout-note}
## Comentários de bloco

Diferentemente de outras linguagens (que usam `/* ... */`), R não possui 
comentários de bloco. Para comentar várias linhas, adicione `#` no 
início de cada uma. No RStudio, selecione as linhas e use o atalho 
`Ctrl+Shift+C` (Windows/Linux) ou `Cmd+Shift+C` (Mac) para 
comentar ou descomentar rapidamente.
:::



## Boas Práticas para Escrever Códigos R

Nomes de variáveis devem começar com uma letra e podem conter 
`letras`, `números`, `_` e `.`

É importante criar nomes de objetos **simples e descritivos** que 
representem claramente seu conteúdo. Em Administração, é comum 
trabalhar com dados financeiros, de desempenho ou de mercado, 
então use nomes que facilitem a compreensão do código.

**Exemplos de boas práticas**:

```{r}
#| eval: false

# Margem bruta da empresa
margem_bruta <- 0.35  

# Fluxo de caixa operacional
fluxo_caixa_operacional <- receita - custos  
```

::: {.callout-tip}
## Estilos de Nomenclatura

- **snake_case**: `margem_bruta`, `fluxo_caixa_operacional` — recomendado no tidyverse
- **camelCase**: `margemBruta`, `fluxoCaixaOperacional`

Escolha um estilo e mantenha a consistência em todo o projeto.
:::


::: {.callout-warning}
## Práticas ruins de nomenclatura

Evite os seguintes práticas:

1. **Nomes genéricos**:

- Ruim: `dados`, `resultado`, `x`
- Melhor: `receita_anual`, `lucro_liquido`


2. **Nomes muito longos**:

- Ruim: `calculo_da_margem_de_contribuicao_ajustada`
- Melhor: `margem_contribuicao`


3. **Espaços nos nomes**:

- Ruim: `margem bruta <- 0.35` (causa erro)
- Melhor: `margem_bruta <- 0.35`


4. **Nomes começando com números**:

- Ruim: `1trimestre <- "Janeiro-Março"` (inválido)
- Melhor: `trimestre1 <- "Janeiro-Março"`


5. **Sobrescrever funções existentes**:

- Ruim: `mean <- 10` (sobrescreve a função `mean()`)
- Melhor: `media <- 10`
:::




## Como Imprimir Informações sobre Objetos

Em R, existem algumas formas simples e eficazes de exibir 
informações sobre objetos ou variáveis. Esses métodos são ideais 
para visualizar valores, depurar código ou criar saídas personalizadas. 
Abaixo estão as principais formas:

**1. Usando** `print()`

A função `print()` é a maneira mais básica de exibir o conteúdo de 
um objeto:

```{r}
# Exemplo: Usando print()
receita <- 850000.50
print(receita)  # Exibe o valor da variável
```

**2. Imprimindo diretamente no console**

Em R, você pode exibir o conteúdo de um objeto simplesmente 
digitando seu nome no console. Isso chama automaticamente 
a função `print()` implicitamente:

```{r}
# digitar o nome do objeto exibe seu valor
receita  
```

**3. Usando a função** `cat()` 

A função `cat()` permite exibir informações de forma mais 
personalizada, combinando texto e valores. É útil para criar 
mensagens ou relatórios simples.

```{r}
# a função cat() combina texto e valor
cat("A receita mensal é:", receita)  
```

**Resumo**:

- Use `print()` para exibir valores de forma explícita.

- Digite o nome do objeto diretamente no console para exibir 
  seu valor de forma rápida.
  
- Use `cat()` para criar saídas personalizadas, combinando 
  texto e valores.




## Tipos Atômicos de Dados

Em R, os dados são armazenados em diferentes tipos atômicos (básicos), 
cada um com características específicas. A @tbl-1 mostra os principais 
tipos.

Tipo          | Classe      | Descrição                          
------------- | ----------- | ----------------------------------
`double`      | `numeric`   | um vetor contendo valores reais (números com casas decimais)
`integer`     | `numeric`   | um vetor contendo valores inteiros (números sem casas decimais)
`character`   | `character` | um vetor contendo valores de texto (caracteres)
`logical`     | `logical`   | um vetor contendo valores lógicos (`TRUE`/`FALSE`)

: Principais Tipos {#tbl-1}


A @tbl-2 exibe alguns tipos especiais que podem aparecer em análises de 
dados. 

Tipo       | Descrição    
-----------|---------------------------------------------  
`NA`       | `Not Available`: representa dados faltantes
`NaN`      | `Not a Number`: (ex: `0 / 0`)
`Inf`      | $+ \infty$ ou $- \infty$: (ex: `1 / 0`)

: Tipos Especiais {#tbl-2}



### A Importância de Conhecer Tipos e Classes de Dados

Na prática da Ciência de Dados, estima-se que analistas e cientistas 
dedicam entre 60% a 80% do tempo de um projeto à importação, limpeza 
e preparação dos dados antes de iniciar análises mais sofisticadas. 
Compreender profundamente os tipos e classes de dados em R é fundamental 
por várias razões:

- **Evita erros sutis de processamento**: Operações matemáticas em 
dados textuais ou cálculos com valores ausentes podem produzir 
resultados inesperados.

- **Otimiza o desempenho**: Estruturas de dados apropriadas melhoram 
a eficiência computacional, especialmente em conjuntos grandes.

- **Facilita transformações**: O conhecimento dos tipos permite 
conversões adequadas (como texto para número) sem perda de informação.

- **Melhora a interpretabilidade**: Identificar corretamente dados 
faltantes (`NA`), indefinidos (`NaN`), ou infinitos (`Inf`) é crucial 
para conclusões válidas.

- **Aumenta a compatibilidade**: Diferentes funções e pacotes em R 
exigem tipos específicos de dados como entrada.

O domínio dos tipos e classes de dados não é apenas uma questão 
técnica, mas um requisito fundamental para análises confiáveis 
em contextos administrativos e financeiros. Este conhecimento 
permite ao analista de dados concentrar-se mais nos insights e 
menos na correção de problemas estruturais nos dados.



### Tipos `double` e `integer`

Em R, existem dois tipos principais de dados numéricos:

- **`double`**: Armazena números com casas decimais (ponto flutuante), 
ideal para valores monetários, índices financeiros, taxas percentuais 
e outras medidas que exigem precisão decimal.

- **`integer`**: Armazena números inteiros sem casas decimais, útil 
para contagens, quantidades discretas e índices em séries temporais.

Na prática de Administração, o tipo `double` é frequentemente 
utilizado para representar valores monetários, taxas de juros ou 
indicadores financeiros, enquanto `integer` é mais comum para 
representar quantidades como número de funcionários, produtos 
vendidos ou períodos de análise.

O sufixo `L` após um número (como em `50L`) indica explicitamente 
que se trata de um valor inteiro. Na maioria das operações, R utiliza 
automaticamente o tipo mais apropriado, o que simplifica a 
programação para análises financeiras e administrativas.

```{r}
# double (números com casas decimais)
receita <- 850000.50  

# integer (números inteiros)
total_funcionarios <- 50L   

# verifica os tipos
typeof(receita)
typeof(total_funcionarios)
```


### classe `numeric`

Apesar dos tipos `double` e `integer` representarem números decimais e 
inteiros de forma diferente, ambos pertencem à classe `numeric`, assim, 
na maioria das situações, você não precisa se preocupar com a possível 
diferença.

```{r}
class(receita)
class(total_funcionarios)
```


**Diferença entre** `typeof` e `class`

Em R, as funções `typeof` e `class` fornecem informações diferentes 
sobre um objeto:

- **`typeof`**: Retorna o **tipo interno** do objeto, ou seja, 
como R armazena o objeto na memória. Por exemplo:

```{r}
#| eval: false
typeof(receita)  # Retorna "double"
typeof(total_funcionarios)  # Retorna "integer"
```

- **`class`**: Retorna a **classe** do objeto, que define como R 
trata o objeto em operações e funções. Por exemplo:

```{r}
#| eval: false
class(receita)  # Retorna "numeric"
class(total_funcionarios)  # Retorna "numeric"
```

Em resumo:

- Use `typeof` para entender como R armazena o objeto internamente.
- Use `class` para entender como R trata o objeto em operações e funções.



### Tipo `character`

O tipo `character` é essencial para armazenar e manipular informações 
textuais. Este tipo de dado armazena sequências de caracteres 
(texto) e é indicado por aspas simples (`'`) ou duplas (`"`).

Em contextos de Administração, o tipo `character` é utilizado 
para armazenar:

- Nomes de empresas, setores ou produtos
- Categorias em classificações de mercado
- Períodos de tempo expressos como texto (Ex: "1° Trimestre 2024")
- Códigos de identificação alfanuméricos
- Observações qualitativas

A manipulação de dados textuais é particularmente importante em 
análises de mercado, pesquisas de satisfação, classificação de 
produtos e organização de relatórios gerenciais, onde a categorização 
textual precede análises quantitativas.


```{r}
# character (texto)
instituicao <- "IFMG - Campus Formiga" 

# verifica o tipo 
typeof(instituicao)
```



### Tipo `logical` 

O tipo `logical` representa valores booleanos (`TRUE` ou `FALSE`) e é 
fundamental para operações condicionais e filtragem de dados.

Em contextos práticos de gestão e finanças, o tipo `logical` 
é utilizado para:

- Verificar condições financeiras (Ex: lucro positivo, meta atingida)
- Filtrar dados que atendem a critérios específicos
- Automatizar decisões baseadas em regras de negócio
- Sinalizar eventos importantes (Ex: inadimplência, quebra de estoque)
- Implementar validações em modelos de previsão

Os valores `TRUE` e `FALSE` devem ser escritos em maiúsculas em R.


```{r}
# logical (lógico, TRUE/FALSE)
lucro_positivo <- TRUE  
lucro_negativo <- FALSE

# verifica o tipo 
typeof(lucro_positivo)
typeof(lucro_negativo)
```

::: {.callout-warning}
## Evite as abreviações `T` e `F`

Embora `T` e `F` funcionem como abreviações de `TRUE` e `FALSE`, eles 
são objetos comuns que podem ser reatribuídos. Isso significa que alguém 
pode escrever `T <- 0` sem que R produza qualquer erro, tornando seu 
código silenciosamente incorreto. Use sempre a forma completa: `TRUE` 
e `FALSE`.

```{r}
# Isso funciona sem erro, mas cria um problema sutil:
T <- 0
T  # Agora T vale 0 em vez de TRUE

# Restaurando o valor original
rm(T)
```
:::



### Tipo Especial `NA`

O tipo especial `NA` (*Not Available*) é comum em análises de dados 
reais, onde frequentemente nos deparamos com informações ausentes. Em 
contextos de Administração e Finanças, dados faltantes podem representar:

- Vendas não realizadas em determinados períodos
- Informações contábeis pendentes
- Valores não reportados em demonstrações financeiras
- Respostas omitidas em pesquisas de mercado
- Métricas não aplicáveis a certos departamentos ou produtos

Identificar e tratar corretamente os valores `NA` é essencial para 
evitar conclusões tendenciosas. R oferece funções específicas 
como `is.na()` para detectar valores ausentes e métodos 
estatísticos para lidar com eles de forma apropriada.

```{r}
# Exemplo: Detectando valores ausentes em dados de vendas 
vendas_trimestrais <- c(150000, 165000, NA, 180000)
is.na(vendas_trimestrais) 

# calculando a média excluindo valores ausentes
mean(vendas_trimestrais, na.rm = TRUE)
```

O tratamento adequado de dados faltantes é uma habilidade 
fundamental em Ciência de Dados.


### Tipo Especial `NaN` 

O valor `NaN` (*Not a Number*) ocorre quando uma operação matemática 
produz um resultado indefinido. Em contextos de gestão e finanças, 
este tipo especial pode surgir em:

- Cálculos de indicadores financeiros com divisores zero
- Operações matemáticas inválidas em modelos preditivos
- Transformações logarítmicas de valores negativos ou zero
- Raízes quadradas de números negativos em análises estatísticas

Enquanto `NA` representa dados ausentes, `NaN` indica especificamente 
um resultado numérico indefinido. Diferenciá-los é importante para 
diagnóstico de problemas em cálculos complexos, como em modelos de 
precificação de ativos ou simulações financeiras.

A função `is.nan()` permite identificar estes valores em conjuntos de dados:

```{r}
# Exemplo: Identificando resultados indefinidos em cálculos financeiros
resultados <- c(25, 0/0, 10)
is.nan(resultados)  
```



### Tipo Especial `inf`

O valor especial `Inf` (e `-Inf` para infinito negativo) ocorre 
principalmente em divisões por zero e representa valores que 
excedem os limites computacionais. Em análises administrativas 
e financeiras, este tipo pode aparecer em:

- Cálculos de taxas de crescimento a partir de valores base zero
- Razões financeiras com denominadores muito próximos a zero
- Projeções exponenciais sem restrições
- Análises de retorno sobre investimento com investimentos mínimos

Diferentemente de `NA` e `NaN`, valores `Inf` podem ser utilizados 
em operações aritméticas seguindo regras matemáticas de infinito:

```{r}
# Exemplo: Comportamento de infinito em operações
infinito_positivo <- 1/0
infinito_positivo + 1000  # Continua sendo Inf
infinito_positivo / 2     # Continua sendo Inf
```

Identificar valores infinitos é importante, por exemplo, 
em modelos financeiros, pois podem indicar problemas estruturais 
nas fórmulas utilizadas ou divisões por zero que 
comprometem a validade das análises.


::: {.callout-tip}
## Sobre Conversão entre Tipos e Classes de Dados

- Você pode estar se perguntando como converter um tipo ou 
classe de dados em outro(a) (por exemplo, transformar um texto em 
número ou vice-versa). 

- Embora R base ofereça funções como `as.numeric()`, `as.character()` e 
`as.logical()` para essas conversões, abordaremos este tópico mais 
adiante no tutorial, quando estudarmos a manipulação de dados com 
o pacote `dplyr`.

- Especificamente, aprenderemos como usar as funções `mutate()` e 
`transmute()` para realizar conversões de tipos de maneira eficiente 
e legível em conjuntos de dados estruturados. Esta abordagem se alinha 
com as práticas modernas de ciência de dados e permite transformar 
múltiplas variáveis simultaneamente dentro de um fluxo de trabalho 
analítico coerente.

- Por enquanto, foque em compreender as características e comportamentos 
dos diferentes tipos de dados apresentados nesta seção, pois este 
conhecimento fundamentará toda sua jornada na análise de dados com R.
:::



## Fatores: Variáveis Categóricas em R {#sec-fatores}

Em análises de dados, muitas variáveis são **categóricas** — representam 
grupos ou categorias em vez de quantidades numéricas. Exemplos: 
departamentos (RH, Financeiro, Comercial), regiões de venda 
(Norte, Sul, Sudeste), segmentos de clientes (Premium, Regular) ou 
níveis de satisfação (Insatisfeito, Neutro, Satisfeito).

Embora seja possível armazenar essas informações com o tipo `character`, 
R oferece uma estrutura específica para esse tipo de dado: o **fator** 
(`factor`). Fatores armazenam variáveis categóricas com um conjunto 
fixo de valores possíveis, chamados de **níveis** (`levels`).

Internamente, um fator é um vetor de números inteiros com um atributo 
`levels` que mapeia cada inteiro para um rótulo textual. Portanto, 
o fator **não** é um tipo atômico — é uma estrutura construída sobre 
o tipo `integer`.


### Criando Fatores

A função `factor()` converte um vetor de texto em fator:

```{r}
#| label: fator-criar
#| echo: true

# Departamentos de uma empresa
departamentos <- c("RH", "Financeiro", "Comercial", "RH", "Comercial")

# Convertendo para fator
departamentos_fator <- factor(departamentos)
departamentos_fator

# Verificando os níveis (categorias únicas)
levels(departamentos_fator)

# Internamente, R armazena como inteiros
typeof(departamentos_fator)
class(departamentos_fator)
```


### Fatores Ordenados (Variáveis Ordinais)

Quando as categorias possuem uma ordem natural (como níveis de 
satisfação ou faixas salariais), use o argumento `ordered = TRUE` 
e especifique a ordem dos níveis:

```{r}
#| label: fator-ordenado
#| echo: true

# Nível de satisfação dos clientes
satisfacao <- c("Satisfeito", "Neutro", "Insatisfeito", 
                "Satisfeito", "Neutro")

# Criando fator ordenado (do menor para o maior)
satisfacao_fator <- factor(
  satisfacao, 
  levels = c("Insatisfeito", "Neutro", "Satisfeito"),
  ordered = TRUE
)

satisfacao_fator

# Agora é possível comparar categorias
satisfacao_fator[1] > satisfacao_fator[3]
```

::: {.callout-note}
## Quando usar `factor` em vez de `character`?

- Use **`factor`** quando a variável tem um conjunto fixo e conhecido 
  de categorias, especialmente se a ordem importa (variáveis ordinais) 
  ou se você precisa controlar a ordem em gráficos e tabelas.

- Use **`character`** quando o texto é livre (nomes de pessoas, 
  observações, descrições) e não representa categorias pré-definidas.

- Na prática, pacotes como `ggplot2` e funções estatísticas tratam 
  fatores de forma diferente de texto — por exemplo, a ordem dos 
  níveis define a ordem das barras em um gráfico.
:::



## Estruturas de Dados em R {#sec-estruturas-dados}

Em R, os dados são organizados em diferentes estruturas, cada uma adequada 
a tipos específicos de operações e análises. As principais estruturas 
de dados abordadas neste capítulo são:

- **Vetores**: Sequências unidimensionais de elementos homogêneos — 
a estrutura fundamental de R.
- **Data Frames**: Estruturas tabulares heterogêneas, equivalentes a uma planilha.
- **Tibbles**: Versão modernizada dos data frames, parte do ecossistema tidyverse.


::: {.callout-note}
## Matrizes e Listas

Matrizes (estruturas bidimensionais homogêneas) e Listas (estruturas que 
combinam objetos de tipos diferentes) também fazem parte da linguagem R. 
Essas estruturas serão apresentadas em capítulos posteriores, quando 
forem necessárias para análises específicas.
:::

A compreensão dessas estruturas facilita uma escolha eficiente para 
diferentes contextos analíticos, sendo essencial para utilizar efetivamente 
os pacotes e recursos avançados do R.



## Vetores {#sec-vetores}

::: {.callout-note icon="false"}
## Importância dos Vetores

- Vetores são a **estrutura fundamental** do R.
- Toda variável simples no R é, por definição, um vetor com comprimento mínimo igual a 1.
- Os elementos em um vetor são sempre do mesmo tipo (homogêneos).
- Dominar vetores é fundamental para compreender estruturas mais complexas, como data frames e listas.
:::



### Criação de Vetores

A função básica para criar vetores é `c()`, que concatena valores.

```{r}
#| label: criacao-vetores
#| echo: true

# Vetor numérico simples
dados <- c(3.5, 4.2, 6.7, 2.3)

# Sequência de números inteiros de 1 a 10
sequencia <- 1:10

# Sequência espaçada uniformemente de 0 a 1 com intervalo 0.25
intervalos <- seq(0, 1, by = 0.25)

# Repetição de um valor lógico
status <- rep(TRUE, times = 5)
```



::: {.callout-tip}
## Coerção implícita em vetores

Se você combinar tipos diferentes em um mesmo vetor, R converte 
automaticamente todos os elementos para um único tipo mais flexível:

```{r}
#| echo: true
c(5, "R", TRUE)  # Todos convertidos para "character"
```
:::



### Indexação de Vetores

Utilize colchetes `[]` para selecionar elementos. É importante 
sem lembrar que a indexação em R começa em 1.

```{r}
#| label: indexacao-vetores
#| echo: true

# Primeiro elemento do vetor
dados[1]

# Último elemento do vetor
dados[length(dados)]

# Removendo o terceiro elemento
dados[-3]

# Selecionando elementos maiores que 4
dados[dados > 4]
```



### Funções Matemáticas Aplicadas a Vetores

R possui diversas funções que facilitam cálculos matemáticos e análises 
estatísticas e que podem ser diretamente aplicadas a vetores. 

Algumas das principais funções são:

```{r}
#| label: funcoes-matematicas-vetores
#| echo: true

vetor_numerico <- c(1, 3, 5, 7, 9)

# soma dos elementos
sum(vetor_numerico)

# soma acumulada
cumsum(vetor_numerico)

# produto dos elementos
prod(vetor_numerico)

# produto acumulado
cumprod(vetor_numerico)

# logaritmo natural dos elementos
log(vetor_numerico)

# exponencial dos elementos
exp(vetor_numerico)

# média
mean(vetor_numerico)

# mediana
median(vetor_numerico)

# desvio-padrão
sd(vetor_numerico)

# variância
var(vetor_numerico)

# valor mínimo
min(vetor_numerico)

# valor máximo
max(vetor_numerico)
```

Essas funções são especialmente úteis em análises estatísticas.



### Operações Vetorizadas e Reciclagem

Operações matemáticas são aplicadas diretamente em vetores, permitindo grande eficiência:

```{r}
#| label: operacoes-vetorizadas
#| echo: true

retornos <- c(0.02, 0.05, -0.03, 0.04)

# Descontando uma taxa fixa (por exemplo, imposto de 10%)
retornos_liquidos <- retornos * (1 - 0.10)

# Usando reciclagem (taxas alternadas)
taxas <- c(0.10, 0.15)
retornos_alternados <- retornos * (1 - taxas)
```



::: {.callout-warning}
## Atenção ao comportamento da reciclagem

Se o tamanho dos vetores for incompatível, R recicla o vetor mais curto,
 o que pode gerar resultados inesperados:

```{r}
#| echo: true

# Vetores com tamanhos diferentes
# geram comportamento inesperado
c(1, 2, 3) + c(10, 20)  
```
:::



### Tipos e Tamanho dos Vetores

Sempre verifique o tipo e comprimento dos vetores para 
evitar problemas na análise:

```{r}
#| label: tipo-comprimento-vetor
#| echo: true

# tipo interno do vetor
typeof(retornos)   

# classe do objeto
class(retornos)   

# tamanho ou número de elementos do vetor
length(retornos) 
```



### Vetores de Texto e Lógicos

Além de numéricos, vetores podem conter caracteres 
(texto) ou valores lógicos:

```{r}
#| label: texto-logico-vetores
#| echo: true

# Cria um vetor de caracteres
instituicoes <- c("IFMG", "UFV", "USP")
# verifica a classe do vetor
class(instituicoes)

# Cria um vetor lógico
metas_atingidas <- c(TRUE, FALSE, TRUE)
# verifica a classe do vetor
class(metas_atingidas)
```




## Data Frames {#sec-dataframes}

As estruturas tabulares organizam informações em formato de tabela, com linhas 
representando observações e colunas representando variáveis. 

Data frames e tibbles constituem a base para a maioria das análises 
estatísticas e financeiras.

Estas estruturas permitem:

- Armazenar dados heterogêneos (números, textos, valores lógicos) de forma organizada
- Aplicar operações estatísticas e transformações por variável
- Integrar-se com pacotes especializados para análises avançadas
- Facilitar a importação e exportação de dados de diversas fontes

Diferentemente das matrizes, data frames e tibbles permitem colunas 
de tipos diferentes.

A data frame é a estrutura de dados mais utilizada em R para análises 
estatísticas. Conceitualmente similar a uma planilha, um data frame organiza 
dados em formato tabular onde cada linha representa uma observação e cada coluna 
representa uma variável.

Um data frame possui as seguintes características:

- **Estrutura tabular**: Todas as colunas devem ter o mesmo comprimento
- **Colunas heterogêneas**: Cada coluna pode conter um tipo diferente de dados
- **Colunas homogêneas**: Dentro de cada coluna, todos os elementos devem ser do mesmo tipo
- **Indexação**: Linhas e colunas podem ser acessadas por índices numéricos ou nomes


### Criando Data Frames

A função `data.frame()` permite criar manualmente uma data frame:

```{r}
#| label: df-criar
#| echo: true

# Dados de desempenho empresarial
empresa <- c("TechCorp", "FinanceMax", "RetailPlus")
receita_milhoes <- c(125.8, 89.3, 156.7)
crescimento_percentual <- c(12.5, -3.2, 8.9)
meta_atingida <- c(TRUE, FALSE, TRUE)

# Criando o data frame
desempenho_empresas <- data.frame(
  empresa = empresa,
  receita_milhoes = receita_milhoes,
  crescimento_percentual = crescimento_percentual,
  meta_atingida = meta_atingida
)

# Exibindo o resultado
desempenho_empresas
```



### Estrutura e Propriedades

Para compreender a estrutura interna de uma data frame, 
podemos utilizar algumas funções específicas:

```{r}
#| label: df-estrutura
#| echo: true

# visão detalhada da data frame
str(desempenho_empresas)

# Dimensões: linhas e colunas
dim(desempenho_empresas)

# Nomes das colunas
names(desempenho_empresas)
```



### Indexação de Data Frames

R oferece múltiplas formas de indexar ou acessar os 
elementos de data frames:

```{r}
#| label: df-acesso
#| echo: true

# Acessando uma coluna específica pelo nome
desempenho_empresas$receita_milhoes

# Acessando múltiplas colunas
desempenho_empresas[c("empresa", "receita_milhoes")]

# Acessando por índices: linha 2, coluna 3
desempenho_empresas[2, 3]

# Filtrando observações por condição
desempenho_empresas[desempenho_empresas$meta_atingida == TRUE, ]
```



### Resumo Estatístico

Para análises preliminares, a função `summary()` fornece 
estatísticas descritivas:

```{r}
#| label: df-summary
#| echo: true

summary(desempenho_empresas)
```




## Tibbles {#sec-tibbles}

Tibbles são uma versão modernizada dos data frames, desenvolvida como parte 
do ecossistema tidyverse. Mantêm compatibilidade com data frames tradicionais, 
mas incorporam melhorias significativas para análise de dados contemporânea.



### Principais Vantagens dos Tibbles

::: {.callout-tip}
## Melhorias em Relação aos Data Frames

- **Exibição otimizada**: Apresenta automaticamente apenas as primeiras linhas e colunas, evitando sobrecarga visual
- **Informações de tipos**: Exibe o tipo de cada coluna na visualização
- **Comportamento previsível**: Evita conversões automáticas indesejadas (como texto para fator)
- **Performance superior**: Operações mais eficientes com conjuntos grandes de dados
- **Integração com tidyverse**: Compatibilidade total com pacotes modernos de análise
:::



### Convertendo Data Frames para Tibbles

::: {.callout-note}
## Instalação e carregamento do pacote `tibble`

O pacote `tibble` faz parte do tidyverse e precisa estar instalado e 
carregado antes de ser utilizado. Caso ainda não tenha feito isso, 
consulte o @sec-rstudio para instruções sobre instalação e carregamento 
de pacotes no RStudio.
:::

```{r}
#| label: tibble-conversao
#| echo: true

library(tibble)

# Convertendo o data frame em tibble
desempenho_tibble <- as_tibble(desempenho_empresas)

# Exibindo o tibble
desempenho_tibble
```



### Criando Tibbles Diretamente

A função `tibble()` permite criar tibbles manualmente:

```{r}
#| label: tibble-criacao
#| echo: true

# Criando tibble com dados financeiros trimestrais
resultados_trim <- tibble(
  trimestre = c("Q1", "Q2", "Q3", "Q4"),
  receita = c(2.8, 3.1, 3.5, 4.2),
  margem_bruta = c(0.32, 0.35, 0.38, 0.41),
  roi = receita * margem_bruta / 2.5  # Calculando ROI diretamente
)

# exibe a tibble
resultados_trim
```




## Erros Comuns para Iniciantes

Ao começar a programar em R, alguns erros são muito frequentes. 
Conhecê-los antecipadamente pode poupar tempo e frustração.


### 1. Esquecer de fechar parênteses ou aspas

Quando o console exibe o sinal `+` na linha seguinte em vez do 
resultado esperado, significa que R está aguardando o restante 
do comando — geralmente um parêntese ou aspas que não foi fechado.

```{r}
#| eval: false
#| echo: true

# Erro: parêntese não fechado
mean(c(10, 20, 30)
```

Pressione `Esc` no console para cancelar o comando incompleto, 
corrija e execute novamente.


### 2. Confundir `=` com `==`

O operador `=` é usado para atribuição (ou dentro de argumentos 
de funções), enquanto `==` é o operador de comparação:

```{r}
#| eval: false
#| echo: true

# Errado: atribui em vez de comparar
lucro = 200000
lucro = 200000   # isso reatribui o valor

# Correto: compara valores
lucro == 200000  # retorna TRUE ou FALSE
```


### 3. Objeto não encontrado (erro de digitação)

R diferencia maiúsculas de minúsculas (*case-sensitive*). 
`Receita`, `receita` e `RECEITA` são três objetos distintos:

```{r}
#| eval: false
#| echo: true

receita <- 500000

# Erro: "Receita" não existe, apenas "receita"
Receita
```

A mensagem `Error: object 'Receita' not found` indica que o nome 
digitado não corresponde a nenhum objeto existente.


### 4. Usar vírgula decimal em vez de ponto

R segue a convenção internacional e utiliza **ponto** como 
separador decimal. O uso de vírgula causa erro de sintaxe:

```{r}
#| eval: false
#| echo: true

# Errado
preco <- 3,14

# Correto
preco <- 3.14
```


### 5. Esquecer de carregar um pacote

Ao tentar usar uma função de um pacote que não foi carregado, 
R exibe a mensagem `could not find function`:

```{r}
#| eval: false
#| echo: true

# Erro se o pacote tibble não foi carregado:
as_tibble(dados)

# Solução: carregar o pacote antes de usar suas funções
library(tibble)
as_tibble(dados)
```

::: {.callout-tip}
## Quando o console mostra `+`

Se o console exibir `+` em vez do prompt `>`, significa que R está 
esperando você completar um comando (geralmente falta fechar um 
parêntese, colchete ou aspas). Pressione **Esc** para cancelar, 
revise o código e execute novamente.
:::



## Síntese do Capítulo

Neste capítulo construímos a base da linguagem R necessária para os 
próximos passos em análise de dados. Os conceitos centrais foram:

- **R é uma linguagem de domínio específico** criada para computação 
  estatística, gratuita, de código aberto e com um vasto ecossistema 
  de pacotes.

- **Em R, tudo é um objeto.** Usamos o operador `<-` para criar e 
  nomear objetos, seguindo convenções de nomenclatura claras 
  (preferencialmente `snake_case`).

- **Funções** são os "verbos" da linguagem — recebem argumentos e 
  produzem resultados. A documentação integrada (`?função`) é a 
  principal ferramenta de aprendizado autônomo.

- **Os tipos atômicos** (`double`, `integer`, `character`, `logical`, 
  `NA`, `NaN`, `Inf`) definem a natureza dos dados armazenados e 
  determinam quais operações são válidas.

- **Operadores** aritméticos, de comparação e lógicos são o vocabulário 
  básico para realizar cálculos e criar condições sobre os dados.

- **Vetores** são a estrutura fundamental do R; **data frames** e 
  **tibbles** organizam dados em formato tabular, com colunas 
  podendo ser de tipos diferentes — estruturas que usaremos em 
  praticamente toda análise de dados.

No próximo capítulo, apresentaremos o sistema Quarto, que permite 
combinar código R, texto narrativo e resultados em documentos 
reproduzíveis.
